// Copyright (c) 2020 Simon Liu. All rights reserved.
#ifndef FINALPROJECT_NEURONS_NETWORK_CONTAINER_H_
#define FINALPROJECT_NEURONS_NETWORK_CONTAINER_H_

#include <flashlight/flashlight.h>
#include "neurons/link.h"
#include "neurons/node.h"

namespace neurons {

// A subclass of fl::Container generated by a neurons::Network
// does not have an "is-a" relationship with fl::Container but rather an
// "implemented-in-terms-of" relationship.
// As fl::Container requires adding layers by fl::Module, whereas this requires
// a Node wrapper and Links to indicate Node connections.
class NetworkContainer : private fl::Container {

 public:

  // Allow access to all methods from fl::Container except fl::Container::add
  using fl::Container::eval;
  using fl::Container::module;
  using fl::Container::modules;
  using fl::Container::param;
  using fl::Container::params;
  using fl::Container::setParams;
  using fl::Container::train;
  using fl::Container::zeroGrad;

  // Public constructor.
  // Checks if passed nodes and links constitute a valid model.
  // Graphs must have no directed cycles, only consist of one component,
  // and have node inputs and node outputs satisfied.
  NetworkContainer(NodeDeque& nodes, const std::deque<Link>& links);

  std::vector<fl::Variable> forward(
      const std::vector<fl::Variable>& input) override;

  fl::Variable forward(const fl::Variable& input);

  fl::Variable operator()(const fl::Variable& input);

  // Generates a stringified representation of the `NetworkContainer` by
  // concatenating string representations for each contained `Module`
  std::string prettyString() const override;

 private:
  // Data node ID
  size_t data_node_id_;

  // Loss node ID
  size_t loss_node_id_;

  // Links connecting the modules
  const std::deque<Link> links_;

};

}  // namespace neurons

#endif  // FINALPROJECT_NEURONS_NETWORK_CONTAINER_H_
